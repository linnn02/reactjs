## 1) Что было не так (до)
Legacy-код был монолитным файлом со следующими проблемами:

- **Глобальные переменные** (cart, products, user, taxRate и т.д.) создавали риск конфликтов имён и делали состояние неявным.
- **Жёсткая связанность (tight coupling):** функции напрямую читали/изменяли глобальное состояние и вызывали друг друга, что усложняло тестирование и изменения.
- **Дублирование логики (DRY нарушен):** несколько одинаковых функций расчёта subtotal/tax/shipping и форматирования денег.
- **Смешение ответственности:** в одном месте и бизнес-логика, и утилиты, и конфиг, и persistence.

## 2) Что сделали (после)
Применили 2 паттерна:

### 2.1 Module Pattern
- Каждый модуль — IIFE с приватным состоянием.
- Наружу отдаётся только публичный API.
- Состояние (cart/products/user) хранится внутри module1.js, а не в глобале.

### 2.2 Namespace Pattern
- Единственный глобальный объект: MyApp.
- Внутри него пространства:
- MyApp.Config — конфигурация
- MyApp.Utils — утилиты
- MyApp.Modules.Core — бизнес-логика

## 3) Разделение по модулям
- module3.js (Config):
хранит taxRate, shippingCost, currency, discount и др.
даёт функции get/set, setDiscount
- module2.js (Utils):
валидации (email/price/quantity)
форматирование formatMoney
обёртка storage (localStorage если доступен)
- module1.js (Core):
продукты: add/remove/list
корзина: add/remove/list
пользователь: set/update/get
расчёты totals + создание заказа processOrder
initializeApp (load из storage)

## 4) Как это решает анти-паттерны
- **Global namespace pollution**: убрали глобальные переменные, оставили только MyApp.
- **Tight coupling**: функции теперь работают через внутреннее состояние и явные API.
- **Duplication**: subtotal/tax/shipping/formatMoney сведены к одной реализации.
- **Структура**: код стал навигационно понятным (папка modules + разделение ролей).

## 5) Что осталось совместимым
- Смысл функциональности не изменился: можно добавлять товары, добавлять в корзину, считать totals, задавать пользователя и оформлять заказ.