## 1) Что есть в legacy-коде (антипаттерны)
- Глобальные переменные и объекты (global namespace pollution) 
- Изменение Object.prototype 
- Дублирование функций валидации email 
- Tight coupling: функции меняют общий глобальный стейт/кэш 
- setTimeout со строками (скрытый eval) 
- document.write 

## 2) Цель рефакторинга
Сохранить функциональность (валидация, работа с пользователем/кэшем, таймеры, расчёты заказа, вывод), но:
- убрать глобальные переменные
- убрать Object.prototype модификации
- убрать строки в setTimeout
- убрать дублирование
- структурировать код

## 3) Какие паттерны применяем
### Module Pattern (Ch.7)
- Три модуля через IIFE:
1) Core (основная логика приложения/состояние)
2) Utils (валидация, форматирование)
3) Config (константы/настройки)

### Namespace Pattern (Ch.11)
- Один глобальный объект MyApp, в котором живут все модули:
- MyApp.Config
- MyApp.Utils
- MyApp.Modules.Core

## 4) План шагов
1) Скопировать legacy в legacy_code.js и пометить антипаттерны комментариями.
2) Создать namespace.js (инициализация MyApp + вложенные namespace).
3) Вынести константы в module3.js (Config).
4) Вынести утилиты в module2.js (Utils), объединить 3 email-валидатора в один.
5) Вынести состояние и бизнес-логику в module1.js (Core) и закрыть приватный стейт.
6) В main.js собрать приложение и запустить MyApp.Modules.Core.initializeApp().